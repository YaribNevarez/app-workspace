/*
 * systool.cpp
 *
 *  Created on: Aug 30, 2017
 *      Author: Yarib Nev√°rez (yarib_007@hotmail.com) - root
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string>
#include <typeinfo>
#include "systool.hpp"
#include "framework/commander.hpp"
#include "framework/systembox.hpp"
#include "framework/joystick.hpp"
#include <signal.h>
#include <time.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <linux/joystick.h>

using namespace SYSTEMBOX;

SystemTool::SystemTool(int argc, char * argv[]):
Application(argc, argv)
{
}

void SystemTool::remote_commander(uint16_t server_port)
{
	TcpServer * server;
	TcpSocket * client;
	std::string message;
	std::string answer;
	bool exit_flag;

	server = new TcpServer(server_port);
	if (server != NULL)
	{
		if (server->prepare() != -1)
		for (;;)
		{
			std::cout << "\nWaiting for connection on server port: " << server_port << std::endl;
			client = server->accept_connection();

			if (client != NULL)
			{
				do
				{
					if (client->receive_buffer(message) > 0)
					{
						std::cout << "\nClient: " << message.c_str();
						exit_flag = Commander::execute(message, answer);
						std::cout << "\nServer: " << answer.c_str();
						client->send_buffer(answer);
					}
					else
					{
						exit_flag = true;
					}
				} while(!exit_flag);

				delete client;
			}
		}
		delete server;
	}

	perror("\nExit");
}

void SystemTool::local_commander(void)
{
	std::string cmd;
	std::string answer;
	bool exit_flag;

	std::cout << "\nWaiting for command ...\n";

	do
	{
		std::getline(std::cin, cmd);
		exit_flag = Commander::execute(cmd, answer);
		std::cout << answer;
	} while(!exit_flag);
}

void SystemTool::device_scanning()
{
	unsigned int data;
    int kbhit = 0;

	Device::InstanceVector instances = Device::get_instanceVector();

	fputs("\e[?25l", stdout); /* hide the cursor */
	system("clear");
	std::cout << "___ Scanning devices. Press ENTER to stop ___";
	for(;kbhit == 0;)
	{
		for (unsigned i = 0; i < instances.size(); i ++)
		{
			instances[i]->read(&data);
			printf("%c[%d;%df %s = 0x%X         ", 0x1B, i + 2, 10,
				   instances[i]->get_name().c_str(), data);
		}
		ioctl(0, FIONREAD, &kbhit);
	}
	getchar();
	system("clear");
	fputs("\e[?25h", stdout); /* show the cursor */
}


#define JOY_DEV "/dev/input/js0"
void SystemTool::joystick_controller(void)
{
	Joystick js(JOY_DEV);
	unsigned int buttons, axis;
    int kbhit = 0;

	fputs("\e[?25l", stdout); /* hide the cursor */
	system("clear");
	std::cout << "___ Scanning Joystick. Press ENTER to stop ___";

	js.open_device();
	buttons = js.get_number_of_buttons();
	axis = js.get_number_of_axis();

	for(;kbhit == 0;)
	{
		for (unsigned i = 0; i < buttons; i ++)
		{
			printf("%c[%d;%df B[%d]=%d ", 0x1B, i + 2, 10,
				   i, js.get_button_value(i));
		}
		for (unsigned i = 0; i < axis; i ++)
		{
			printf("%c[%d;%df A[%d]=%d     ", 0x1B, i + 2 + buttons, 10,
				   i, js.get_axis_value(i));
		}
		ioctl(0, FIONREAD, &kbhit);

		pwm_0.set_value(js.get_axis_value(0));
		pwm_1.set_value(js.get_axis_value(2));
	}
	getchar();
	system("clear");
	fputs("\e[?25h", stdout); /* show the cursor */
}
//void SystemTool::joystick_controller(void)
//{
//	int joy_fd, *axis=NULL, num_of_axis=0, num_of_buttons=0, x;
//	char *button=NULL, name_of_joystick[80];
//	struct js_event js;
//
//	if( ( joy_fd = open( JOY_DEV , O_RDONLY)) == -1 )
//	{
//		printf( "Couldn't open joystick\n" );
//		return;
//	}
//
//	ioctl(joy_fd, JSIOCGAXES, &num_of_axis );
//	ioctl(joy_fd, JSIOCGBUTTONS, &num_of_buttons );
//	ioctl(joy_fd, JSIOCGNAME(80), &name_of_joystick );
//
//	axis = (int *) calloc( num_of_axis, sizeof( int ) );
//	button = (char *) calloc( num_of_buttons, sizeof( char ) );
//
//	printf("Joystick detected: %s\n\t%d axis\n\t%d buttons\n\n"
//		, name_of_joystick
//		, num_of_axis
//		, num_of_buttons );
//
//	fcntl( joy_fd, F_SETFL, O_NONBLOCK );	/* use non-blocking mode */
//
//	for(;;)
//	{
//		read(joy_fd, &js, sizeof(struct js_event));
//
//		switch (js.type & ~JS_EVENT_INIT)
//		{
//			case JS_EVENT_AXIS:
//				axis   [ js.number ] = js.value;
//				break;
//			case JS_EVENT_BUTTON:
//				button [ js.number ] = js.value;
//				break;
//		}
//
//		printf( "TYPE(0x%X) X: %6X  Y: %6X  ", js.type, axis[0], axis[1] );
//
//		if( num_of_axis > 2 )
//			printf("Z: %6d  ", axis[2] );
//
//		if( num_of_axis > 3 )
//			printf("R: %6d  ", axis[3] );
//
//		if( num_of_axis > 4 )
//			printf("R: %6d  ", axis[4] );
//
//		if( num_of_axis > 5 )
//			printf("R: %6d  ", axis[5] );
//
//		for( x=0 ; x<num_of_buttons ; ++x )
//			printf("B%d: %d  ", x, button[x] );
//
//		printf("  \r");
//		fflush(stdout);
//	}
//
//	close( joy_fd );	/* too bad we never get here */
//}

int SystemTool::run(void)
{
	int tcp_port = 0;
	char op;

	system("clear");

	if (passed_arg() >= 2)
	{
		op = passed_arg(1)[0];

		if (passed_arg() > 2)
		{
			tcp_port = strtoul(passed_arg(2).c_str(), NULL, 0);
		}
	}
	else
	{
		std::cout << "\n***** Local SysTool *****";
		std::cout << "\n\nOptions:";
		std::cout << "\n 1   - Server commander";
		std::cout << "\n 2   - Local commander";
		std::cout << "\n 3   - Device scanning";
		std::cout << "\n 4   - Joystick controller";
		std::cout << "\n XXX - Exit";
		std::cout << "\n\nSelect: ";

		op = std::cin.get();
	}

	switch(op)
	{
	case '1':
		if (tcp_port == 0)
		{
			std::cout << "\nTCP/IP port number: ";
			std::cin >> tcp_port;
		}
		remote_commander(tcp_port);
		break;
	case '2':
		local_commander();
		break;
	case '3':
		device_scanning();
		break;
	case '4':
		joystick_controller();
		break;
	default:;
	}

    return EXIT_SUCCESS;
}

SystemTool::~SystemTool()
{
}
